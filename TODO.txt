INFO STUFF FOR INTERVIEWS ->
TREES
    - LOTS OF TREES 
    - AVL, FUSSION, SPLAY, RED BLACK, B+ (self balancing)
    - AVL / RED BLACK TREES 
        -
        -
    - FULL, COMPLETE, PERFECT (APPLIES TO BINARY TREES)
    - FULL 
        - EVERY OTHER NODE EXCEPT LEAF HAS TWO NODES 
    - COMPLETE 
        - ALL NODES ARE FULL EXCEPT LAST LEVEL
        - LEFT SHIFTED 
    - PERFECT   
        - ALL NODES ARE FULL
    - BINARY SEARCH 
        - EVERY NODE IS LESS THAN THE PREVIOUS A1 < A2 < ... < AN 
    - K-ARY TREE/ D-ARY TREE
        - time complixty changes by the number of nodes and height 
        - O(log{k}(h)) k subproblems at h height 
         - 
    - COMMON PROBS 
        - SEARCH BINARY TREE
        - ROTATED BINARY TREE (TO DO)
        - MAX DEPTH 
        - LEAST COMMONA ANCESTOR
        - INVERTED BINARY TREE 
    
TRIE (implemented in C++)

LINKED LIST 
    - DOUBLY - POINTS TO NEXT AND PREDECESOR 
    - SINGLY - POINTS TO NEXT 
    - BOTH HAVE SIMILAR STRUCTURE 
    - INSERT, DELETE OPS IN O(1) time 
        Search is O(N) -> amortized time -> theta(1) avg over all 
    - IMPLEMENTED EITHER RECURSIVLY OR ITERATIVELY 
    - COMMON PROBS
        - CYCLES 
        - MERGE K SORTED LISTS
        - REMOVING A NODE 

HEAPS 
    MIN HEAP -> IN C++ use comparison paremeter greter<...>
    MAX HEAP -> LARGEST ELTS FIRST 
    USED WHEN YOU WANT THE K LARGEST OR K SMALLEST ITEMS/NUMBERS/ETC 
    DEPENDS HOW YOU DEFINE A PARTICULAR DATA STRUCTURE USING TYPEDEFS 

TRAVERSALS / WALKING
    TREE TRAVERSALS -> IN ORDER, POST ORDER, PRE ORDER 
        IN ORDER -> TRAVERSE LEFT SUBTREE, VISIT ROOT, THEN TRAVERSE RIGHT SUBTREE
        PRE ORDER -> VISIT ROOT, TRAVERSE LEFT, TRAVERSE RIGHT 
        POST ORDER -> TRAVERSE LEFT, TRAVERSE RIGHT, VISIT ROOT 

MASTER THEOREM (MEMORIZE)


HASHTABLES 



