INFO STUFF FOR INTERVIEWS ->

SATURDAY -> FEB 2ND 
* SIMPLE TREES
    - LOTS OF TREES 
    - AVL, FUSSION, SPLAY, RED BLACK, B+ (self balancing)
    - AVL / RED BLACK TREES #################################### LOOK AT VIDEOS LATER
        - BOTH SELF BALANCING TREES
        - AVL   
            - DIFFERENCE BETWEEN LEFT AND RIGHT SUBTREE NO GREATER THAN 1 
            - MIN MAX SEARCH DELETE TAKE O(H) TIME 
            - SKEWED TREES AT MOST O(N)
            - HEIGHT OF AVL IS ALWAYS O(LOG(N))
            - PERFORM SOME REBALANCING TO MAINTAIN O(LOG(N))
            - FOLLOWING TWO PROPS W/O VIOLATING BST PROPS 
                - LEFT ROTATION
                - RIGTH ROTATION 
            - STEPS FOR INSERT 
                - 1/ PERFORM STANDARD BST TO INSERT W 
                - 2/ FROM W TRAVEL UP TO THE FIRST UNBALANCED NODE 
                - 3/ PERFORM APPROPRIATE ROTATIONS 
                - 4/ 4 CASES TO CONSIDER 
                    1/ LEFT LEFT CASE 
                    2/ LEFT RIGTH CASE 
                    3/ RIGHT RIGHT CASE 
                    4/  RIGHT LEFT CASE 
            - CAUSE MORE ROTATIONS ON INSERTIONS AND DELETIONS 

        - RED BLACK TREES 
            - EVERY NODE IS EITHER RED OR BLACK 
            - ROOT OF THE TREE IS ALWAYS BLACK
            - THERE ARE NO TWO ADJANCENT NODES 
            - 
        - IF SEARCH IS FREQUENT CHOSE AVL
    - BINARY TREES
        - RECURSION TAKES UP O(N) SPACE ON CALL STACK
        - TRICKS SUCH AS ITERATIVE IMPLENTATIONS TAKE O(1)
        - APPLIES TO OTHER TREES AS WELL NOT JUST BINARY
    - TYPES 
        - FULL, COMPLETE, PERFECT (APPLIES TO BINARY TREES)
        - FULL 
            - EVERY OTHER NODE EXCEPT LEAF HAS TWO NODES 
        - COMPLETE 
            - ALL NODES ARE FULL EXCEPT LAST LEVEL
            - LEFT SHIFTED 
        - PERFECT   
            - ALL NODES ARE FULL
    - BINARY SEARCH 
        - EVERY NODE IS LESS THAN THE PREVIOUS A1 < A2 < ... < AN 
    - K-ARY TREE/ D-ARY TREE
        - time complixty changes by the number of nodes and height 
        - O(log{k}(h)) k subproblems at h height 
         - 
    - LEFT AND RIGTH SKEWED TREES
        - COMPLEXIY O(N) RATHER THAN O(H) 
        - RECALL O(H) IS HEIGHT WHICH TRANSLATES TO O(LOG(N)) [BALANCED TREES]
    - TRAVERSALS / WALKING
        TREE TRAVERSALS -> IN ORDER, POST ORDER, PRE ORDER 
            IN ORDER -> TRAVERSE LEFT SUBTREE, VISIT ROOT, THEN TRAVERSE RIGHT SUBTREE
            PRE ORDER -> VISIT ROOT, TRAVERSE LEFT, TRAVERSE RIGHT 
            POST ORDER -> TRAVERSE LEFT, TRAVERSE RIGHT, VISIT ROOT 
    - COMMON PROBS 
        - SEARCH BINARY TREE
        - ROTATED BINARY TREE (TO DO)
        - MAX DEPTH 
        - LEAST COMMONA ANCESTOR
        - INVERTED BINARY TREE 
    
* TRIE (SPECIFIC TREE) (implemented in C++)

* LINKED LIST 
    - DOUBLY - POINTS TO NEXT AND PREDECESOR 
    - SINGLY - POINTS TO NEXT 
    - BOTH HAVE SIMILAR STRUCTURE 
    - INSERT, DELETE OPS IN O(1) time 
        Search is O(N) -> amortized time -> theta(1) avg over all 
    - IMPLEMENTED EITHER RECURSIVLY OR ITERATIVELY 
    - REMEMBER TO UPDATE NEXT POINTER
    - SPACE
        - RECURSION TAKES UP O(N) SPACE ON CALL STACK
        - TRICKS SUCH AS ITERATIVE IMPLENTATIONS TAKE O(1)
    - TRICKS 
        - COMMONT TO HAVE TWO ITERATORS WHEN USING A SINGLY LINKED LIST
    - COMMON PROBS
        - CYCLES (CAN BENIFIT USING TWO ITERATORS A FAST AND SLOW ONE)
        - MERGE K SORTED LISTS
        - REMOVING A NODE 

* HEAPS 
    ALSO KNOWN AS A PRIORITY QUEUE, EACH ELT BEHAVES AS A PRIORITY ELT ON A QUEUE 
    MIN HEAP -> IN C++ use comparison paremeter greter<...>
    MAX HEAP -> LARGEST ELTS FIRST 
    KEYS AT EACH NODE IS AS LEAST AS GREAT AS STORED IN CHILDREN
        CHILDREN AT NODE I ARE 2I + 1 AND 2I + 2 
    USED WHEN YOU WANT THE K LARGEST OR K SMALLEST ITEMS/NUMBERS/ETC 
        LARGEST OR SMALLEST ELTS 
        BUT DONT CARE ABOUT FAST LOOKUP, DELETE, SEARCH 
    DEPENDS HOW YOU DEFINE A PARTICULAR DATA STRUCTURE USING TYPEDEFS 
    O(1) LOOK UP TO FOR MAX/MIN
    O(LOG) INSERTIONS 
    O(N) SEARCH 
    O(NLOGN) FOR N INSERTIONS 
    STUFF TO LATER LEARN -> BINOMIAL HEAPS AND FIBONACCI HEAPS (GRADUATE STUFF)

* STACKS
    - O(1) AMORTIZED INSERT, POP/DELETE
    - FIFO (FIRST IN FIRST OUT)
    - THINK OF PLACING DISHES ON A PILE FOR A PERSON TO CLEAN
        - THE MOST RECENT ONE (FIRST IN), GETS CLEANED 

* QUEUES
    - O(1) AMORTIZED INSERT, POP/DELETE
    - LIFO (LAST IN FIRST OUT)
    - THINK OF WAITING IN LINE 
        - THE PERSON WAITING THE LONGEST IS THE FIRST PERSON TO ... ETC 
        - OF COURSE THIS IS NOT TRUE FOR ALL CASES BUT THE GIST IS LIFO 

* MASTER THEOREM (MEMORIZE)


* HASHTABLES 


* AMORTIZED ANALYSIS



PROBLEMS TO DO: 
    K SORTED LISTS 
    REVERSE A LINKED LIST
    MAX PROFIT 
    TRIE PROBLEM
    ROTATED TREE (BINARY SEARCH)
    AVL/REDBLACK TREE 


SUNDAY FEB 3RD 





