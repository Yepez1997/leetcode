INFO STUFF FOR INTERVIEWS ->

SATURDAY -> FEB 2ND 
* SIMPLE TREES
    - LOTS OF TREES 
    - AVL, FUSSION, SPLAY, RED BLACK, B+ (self balancing)
    - AVL / RED BLACK TREES 
        -
        -
    - BINARY TREES
        - RECURSION TAKES UP O(N) SPACE ON CALL STACK
        - TRICKS SUCH AS ITERATIVE IMPLENTATIONS TAKE O(1)
        - APPLIES TO OTHER TREES AS WELL NOT JUST BINARY
    - TYPES 
        - FULL, COMPLETE, PERFECT (APPLIES TO BINARY TREES)
        - FULL 
            - EVERY OTHER NODE EXCEPT LEAF HAS TWO NODES 
        - COMPLETE 
            - ALL NODES ARE FULL EXCEPT LAST LEVEL
            - LEFT SHIFTED 
        - PERFECT   
            - ALL NODES ARE FULL
    - BINARY SEARCH 
        - EVERY NODE IS LESS THAN THE PREVIOUS A1 < A2 < ... < AN 
    - K-ARY TREE/ D-ARY TREE
        - time complixty changes by the number of nodes and height 
        - O(log{k}(h)) k subproblems at h height 
         - 
    - LEFT AND RIGTH SKEWED TREES
        - COMPLEXIY O(N) RATHER THAN O(H) 
        - RECALL O(H) IS HEIGHT WHICH TRANSLATES TO O(LOG(N)) [BALANCED TREES]
    - TRAVERSALS / WALKING
        TREE TRAVERSALS -> IN ORDER, POST ORDER, PRE ORDER 
            IN ORDER -> TRAVERSE LEFT SUBTREE, VISIT ROOT, THEN TRAVERSE RIGHT SUBTREE
            PRE ORDER -> VISIT ROOT, TRAVERSE LEFT, TRAVERSE RIGHT 
            POST ORDER -> TRAVERSE LEFT, TRAVERSE RIGHT, VISIT ROOT 
    - COMMON PROBS 
        - SEARCH BINARY TREE
        - ROTATED BINARY TREE (TO DO)
        - MAX DEPTH 
        - LEAST COMMONA ANCESTOR
        - INVERTED BINARY TREE 
    
* TRIE (SPECIFIC TREE) (implemented in C++)

* LINKED LIST 
    - DOUBLY - POINTS TO NEXT AND PREDECESOR 
    - SINGLY - POINTS TO NEXT 
    - BOTH HAVE SIMILAR STRUCTURE 
    - INSERT, DELETE OPS IN O(1) time 
        Search is O(N) -> amortized time -> theta(1) avg over all 
    - IMPLEMENTED EITHER RECURSIVLY OR ITERATIVELY 
    - REMEMBER TO UPDATE NEXT POINTER
    - SPACE
        - RECURSION TAKES UP O(N) SPACE ON CALL STACK
        - TRICKS SUCH AS ITERATIVE IMPLENTATIONS TAKE O(1)
    - TRICKS 
        - COMMONT TO HAVE TWO ITERATORS WHEN USING A SINGLY LINKED LIST
    - COMMON PROBS
        - CYCLES (CAN BENIFIT USING TWO ITERATORS A FAST AND SLOW ONE)
        - MERGE K SORTED LISTS
        - REMOVING A NODE 

* HEAPS 
    ALSO KNOWN AS A PRIORITY QUEUE, EACH ELT BEHAVES AS A PRIORITY ELT ON A QUEUE 
    MIN HEAP -> IN C++ use comparison paremeter greter<...>
    MAX HEAP -> LARGEST ELTS FIRST 
    KEYS AT EACH NODE IS AS LEAST AS GREAT AS STORED IN CHILDREN
        CHILDREN AT NODE I ARE 2I + 1 AND 2I + 2 
    USED WHEN YOU WANT THE K LARGEST OR K SMALLEST ITEMS/NUMBERS/ETC 
        LARGEST OR SMALLEST ELTS 
        BUT DONT CARE ABOUT FAST LOOKUP, DELETE, SEARCH 
    DEPENDS HOW YOU DEFINE A PARTICULAR DATA STRUCTURE USING TYPEDEFS 
    O(1) LOOK UP TO FOR MAX/MIN
    O(LOG) INSERTIONS 
    O(N) SEARCH 
    O(NLOGN) FOR N INSERTIONS 
    STUFF TO LATER LEARN -> BINOMIAL HEAPS AND FIBONACCI HEAPS (GRADUATE STUFF)


* MASTER THEOREM (MEMORIZE)


* HASHTABLES 


* AMORTIZED ANALYSIS



PROBLEMS TO DO: 
    K SORTED LISTS 
    MAX PROFIT 
    TRIE PROBLEM
    ROTATED TREE (BINARY SEARCH)


SUNDAY FEB 3RD 





