INFO STUFF FOR INTERVIEWS ->

SATURDAY -> FEB 2ND 
* SIMPLE TREES
    - LOTS OF TREES 
    - AVL, FUSSION, SPLAY, RED BLACK, B+ (self balancing)
    - AVL / RED BLACK TREES #################################### LOOK AT VIDEOS LATER
        - BOTH SELF BALANCING TREES
        - AVL   
            - DIFFERENCE BETWEEN LEFT AND RIGHT SUBTREE NO GREATER THAN 1 
            - MIN MAX SEARCH DELETE TAKE O(H) TIME 
            - SKEWED TREES AT MOST O(N)
            - HEIGHT OF AVL IS ALWAYS O(LOG(N))
            - PERFORM SOME REBALANCING TO MAINTAIN O(LOG(N))
            - FOLLOWING TWO PROPS W/O VIOLATING BST PROPS 
                - LEFT ROTATION
                - RIGTH ROTATION 
            - STEPS FOR INSERT 
                - 1/ PERFORM STANDARD BST TO INSERT W 
                - 2/ FROM W TRAVEL UP TO THE FIRST UNBALANCED NODE 
                - 3/ PERFORM APPROPRIATE ROTATIONS 
                - 4/ 4 CASES TO CONSIDER 
                    1/ LEFT LEFT CASE 
                    2/ LEFT RIGTH CASE 
                    3/ RIGHT RIGHT CASE 
                    4/  RIGHT LEFT CASE 
            - CAUSE MORE ROTATIONS ON INSERTIONS AND DELETIONS 

        - RED BLACK TREES 
            - EVERY NODE IS EITHER RED OR BLACK 
            - ROOT OF THE TREE IS ALWAYS BLACK
            - THERE ARE NO TWO ADJANCENT NODES 
            - CONSRAINTS TO FOLLOW 
                - HEIGHT FROM ROOT MUST == SAME NUMBER OF BLACK NODES LEFT AND RIGHT SUB TREES
                - LEAFS HAVE TWO BLACK NODES NIL NODES
                - BLACK NODES HAVE TWO RED NODES 
                -
        - IF SEARCH IS FREQUENT CHOSE AVL
    - BINARY TREES
        - RECURSION TAKES UP O(N) SPACE ON CALL STACK
        - TRICKS SUCH AS ITERATIVE IMPLENTATIONS TAKE O(1)
        - APPLIES TO OTHER TREES AS WELL NOT JUST BINARY
    - TYPES 
        - FULL, COMPLETE, PERFECT (APPLIES TO BINARY TREES)
        - FULL 
            - EVERY OTHER NODE EXCEPT LEAF HAS TWO NODES 
        - COMPLETE 
            - ALL NODES ARE FULL EXCEPT LAST LEVEL
            - LEFT SHIFTED 
        - PERFECT   
            - ALL NODES ARE FULL
    - K-ARY TREE/ D-ARY TREE
        - time complixty changes by the number of nodes and height 
        - O(log{k}(h)) k subproblems at h height 
         - 
    - LEFT AND RIGTH SKEWED TREES
        - COMPLEXIY O(N) RATHER THAN O(H) 
        - RECALL O(H) IS HEIGHT WHICH TRANSLATES TO O(LOG(N)) [BALANCED TREES]
    - TRAVERSALS / WALKING
        TREE TRAVERSALS -> IN ORDER, POST ORDER, PRE ORDER 
            IN ORDER -> TRAVERSE LEFT SUBTREE, VISIT ROOT, THEN TRAVERSE RIGHT SUBTREE
            PRE ORDER -> VISIT ROOT, TRAVERSE LEFT, TRAVERSE RIGHT 
            POST ORDER -> TRAVERSE LEFT, TRAVERSE RIGHT, VISIT ROOT 
    - COMMON PROBS 
        - SEARCH BINARY TREE
        - ROTATED BINARY TREE (TO DO)
        - MAX DEPTH 
        - LEAST COMMONA ANCESTOR
        - INVERTED BINARY TREE 

 * BINARY SEARCH 
        - EVERY NODE IS LESS THAN THE PREVIOUS A1 < A2 < ... < AN 
        - SINCE ITEMS ARE SORTED IF WE CHOSE AN ELT FROM MIDDLE, PIVOT LEFT OR PIVOT RIGHT 
            - DEPENDS ON THE TARGET NUMBER 
        - IN ESSENCE THE PROBLEM IS DIVIDED BY HALF
        - n * (1/2)**x = 1 -> log{2}(x)
    
* TRIE (SPECIFIC TREE) (implemented in C++)

* LINKED LIST 
    - DOUBLY - POINTS TO NEXT AND PREDECESOR 
    - SINGLY - POINTS TO NEXT 
    - BOTH HAVE SIMILAR STRUCTURE 
    - INSERT, DELETE OPS IN O(1) time 
        Search is O(N) -> amortized time -> theta(1) avg over all 
    - IMPLEMENTED EITHER RECURSIVLY OR ITERATIVELY 
    - REMEMBER TO UPDATE NEXT POINTER
    - SPACE
        - RECURSION TAKES UP O(N) SPACE ON CALL STACK
        - TRICKS SUCH AS ITERATIVE IMPLENTATIONS TAKE O(1)
    - TRICKS 
        - COMMONT TO HAVE TWO ITERATORS WHEN USING A SINGLY LINKED LIST
    - COMMON PROBS
        - CYCLES (CAN BENIFIT USING TWO ITERATORS A FAST AND SLOW ONE)
        - MERGE K SORTED LISTS
        - REVERSE A LINKED LIST 
        - REMOVING A NODE 

* HEAPS 
    ALSO KNOWN AS A PRIORITY QUEUE, EACH ELT BEHAVES AS A PRIORITY ELT ON A QUEUE 
    MIN HEAP -> IN C++ use comparison paremeter greter<...>
    MAX HEAP -> LARGEST ELTS FIRST 
    KEYS AT EACH NODE IS AS LEAST AS GREAT AS STORED IN CHILDREN
        CHILDREN AT NODE I ARE 2I + 1 AND 2I + 2 
    USED WHEN YOU WANT THE K LARGEST OR K SMALLEST ITEMS/NUMBERS/ETC 
        LARGEST OR SMALLEST ELTS 
        BUT DONT CARE ABOUT FAST LOOKUP, DELETE, SEARCH 
    DEPENDS HOW YOU DEFINE A PARTICULAR DATA STRUCTURE USING TYPEDEFS 
    O(1) LOOK UP TO FOR MAX/MIN
    O(LOG) INSERTIONS 
    O(N) SEARCH 
    O(NLOGN) FOR N INSERTIONS 
    STUFF TO LATER LEARN -> BINOMIAL HEAPS AND FIBONACCI HEAPS (GRADUATE STUFF)

* STACKS
    - O(1) AMORTIZED INSERT, POP/DELETE
    - LIFO (LAST IN FIRST OUT)
    - THINK OF PLACING DISHES ON A PILE FOR A PERSON TO CLEAN
        - THE MOST RECENT ONE (FIRST IN), GETS CLEANED 

* QUEUES
    - O(1) AMORTIZED INSERT, POP/DELETE
     - FIFO (FIRST IN FIRST OUT)
    - THINK OF WAITING IN LINE 
        - THE PERSON WAITING THE LONGEST IS THE FIRST PERSON TO ... ETC 
        - OF COURSE THIS IS NOT TRUE FOR ALL CASES BUT THE GIST IS LIFO 

* MASTER THEOREM (MEMORIZE)


* HASHTABLES 
    - O(1) ACCESS TIME 
    - O(N) SEARCH 
    - O(N) SPACE 
    - HASH FUNCTION 
    - COLLISIONS FORM CHAINING 
    - CUKOO HASHING 
    - PERFECT HASHING 


* AMORTIZED ANALYSIS
    - Averaging over all 
    - Potentail Method



PROBLEMS TO DO: 
    K SORTED LISTS 
    REVERSE A LINKED LIST // ALMOST DONE 
    TRIE PROBLEM -> WORD SEARCH I, II, III 
    ROTATED TREE (BINARY SEARCH) 
    AVL/REDBLACK TREE 


SUNDAY FEB 3RD 


* GRAPHS
    - TYPES OF GRAPHS 
        - DIRECTED, ACYCYLIC, UNDIREDTED, CYCLIC
        - WEIGHTED AND UNWEIGHTED 
        - DAGS CONTAIN NO CYCLES 
        - NO INCOMING EDGES -> SOURCE
        - NO OUTGOING EDEGS -> SINK
        - CONNECTED IF THERE EXISTS PATH FROM U TO V 
    - REPRESENTATION IN ADJ LIST OR MATRIX 
        - ADJ LIST -> O(V + E) SPACE 
                    -> O(V + E) ACCESS 
        - MATRIX -> O(V**2) SPACE   
                -> O(1) ACCESS TIME  
    - DEPTH FIRST SEARCH 
        - LESS MEMORY THAN DFS 
        - EASILY IMPLEMENTED W/ RECURRSION 
        - TRAVERSE DEPTH FIRST 
        - START AND FINISH TIMES 
        - CAN BE IMPLEMENTED WITH A STACK 
  
    - KOSARAJUS STRONGLY CONNECTED COMPONETS ALG 
        - RUN DFS ON ORIGINAL AND GRAPH TRANSPOSED      
    - BREATH FIRST SEARCH 
        - EXPLORING A TREE OR GRAPH 
        - SHORTEST PATH BETWEEN START AND ANY OTHER POINT
        - DFS WILL NOT NECC FIND SINGLE SHORTEST PATH 
        - GENERALLY REQUIRES MORE MEMORY THAN DFS
        - IMPLEMENTED WITH QUEUE 
        - SIMILAR TO DIJKSTRA W/ ONLY NON WEIGTHS
    - DIJKSTRA
        - RELIES ON RELAXTION PROPERTY
        - SINGLE SHORTES PATH ON WEIGHTED NON NEGATIVE EDGES
        - IMPLEMENTED WITH PRIORITY QUEUE, FASTEST IMPLEMENT WITH FIBONACCI HEAPS 
    - BELLMAN FORD 
        - RUNS ON NEGATIVE EDGES UP TO V TIMES 
        - OUTPUTS IF THERE EXISTS A NEGATIVE CYCLE 
        - OR IF A VALID SHORTEST PATH EXISTS WITH NEGATIVE WEIGHTS
    - TOPOLOGICAL SORT 
        - NODES IN DIRECTED ACYCLIC GRAPH IN ORDER BASED ON EDGES 
        - DFS USEFUL 
    - MIN SPAN TREES 
        - IE FIND THE CHEAPEST EDGES THAT REACH ALL NODES IN A WEIGHTED GRAPH
        - GREEDY ALGS 
        - CUT PROPERTY
        - MATROIDS 
        - KRUSKAL 
            - SORT IN NON DECREASING ORDER 
            - CHOSE THE LEAST POSSIBLE WEIGHT THAT DOES NOT FORM A CYCLE
            - REPEAT AS LONG AS NON CYCLE IS FORMED 
            - USES UNION FIND 
                - PATH COMPRESSION 
                - UNION BY RANK 
        - PRIMS 
            - BASICALLY CHOSE THE MIN WEIGHT THATS NOT 
            INCLUDED IN THE MST 
   
MONDAY FEB 4TH

    - DYNAMIC PROGRAMMING 
        - BOTTOM UP
            - THE KEY IS TO BUILD SOLUTIONS OFF THE PREVIOUS 
        - TOP DOWN  (MEMOIZATION)
            - MORE COMPLEX SINCE LESS CONCRETE 
            - DIVIDE THE CASE FOR N INTO SUBPROBLEMS 
        - HALF AND HALF 
            - DIVIDE THE DATA SET IN HALF 
                - EX. BINARY SEARCH 
        - RECURSIVE OR ITERATIVE 
            - RECURSIVE TAKES O(N) SPACE -> CALL STACK
            - WHEN RECURSIVE -> USUALLY STORE W/ HASHTABLE OR BINARYTREE
            - WHEN ITERATIVE -> 1D OR 2D ARRAY 
         
        - OVERLAPPING SUB PROBLEMS & COMBINING SOLUTIONS 
        - FIBONACCI 
            - TOTAL NUMBER OF NODES IS THE RUNTIME 2**N 
        - MAKE CHOICES TO ARRIVE AT SOLUTION 
        - EFFICIENTLY TO CACHE RESULTS 
        - COUNTING AND DECISION PROBLEMS 

    - GREEDY ALGORITHMS 
        - EACH STEP MAKES LOCALLY OPTIMUM DECISION 
        - NOT ALWAYS THE GLOBALLY OPTIMUM 
            -> COIN CHANGE 
            -> 0/1 KNAPSACK VS FRACTIONAL KNAPSACK 
        - NATURAL SET OF CHOICES TO SELECT FROM
        - IF IT DOES NOT PRODUCE AN OPT RESULT, VIEW IT AS A HEURISTIC
        
    - RECURSION
        - DEFINE THE PROBLEM: VARIABLES AND STATEMENT
        - SET UP A MATHEMATICAL RECURSIVE FORMULA
            - BASE CASE & RECURRENT CASE 
            - USUALLY WITH PIECE WISE MATH FUNCTIONS 
        - TIME AND SPACE COMPLEXIY
            - USUALLY CAN IMPROVE IF THERE EXISTS A BOTTOM UP APPROACH





